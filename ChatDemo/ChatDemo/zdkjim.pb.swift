// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: zdkjim.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///1、连接服务器
///
///2、鉴权
///
///3、登录（可免）
///
///4、进入群组（可免）
///
///5、获取在线列表
///
///6、聊天

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///设备类型
enum DeviceType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknow // = 0

  ///PC
  case pc // = 1

  ///安卓
  case android // = 2

  ///IOS
  case ios // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknow
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknow
    case 1: self = .pc
    case 2: self = .android
    case 3: self = .ios
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknow: return 0
    case .pc: return 1
    case .android: return 2
    case .ios: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

enum Command: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknow // = 0

  ///握手请求，含http的websocket握手请求
  case handshakeReq // = 1

  ///握手响应，含http的websocket握手响应
  case handshakeResp // = 2

  ///鉴权请求
  case authReq // = 3

  /// 鉴权响应
  case authResp // = 4

  ///申请进入群组
  case joinGroupReq // = 5

  ///申请进入群组响应
  case joinGroupResp // = 6

  ///进入群组通知
  case joinGroupNotifyResp // = 7

  ///退出群组通知
  case exitGroupNotifyResp // = 20

  ///聊天请求
  case chatReq // = 8

  ///聊天响应
  case chatResp // = 9

  ///下面的还没实现 start
  case startShowReq // = 10

  ///开播响应
  case startShowResp // = 11

  ///停播请求
  case endShowReq // = 12

  ///停播通知
  case endShowNotifyResp // = 13

  ///心跳请求
  case heartbeatReq // = 14

  ///关闭请求
  case closeReq // = 15

  ///分页请求Client列表
  case clientPageReq // = 16

  ///返回Client列表
  case clientPageResp // = 17

  ///登录请求
  case loginReq // = 18

  ///登录响应
  case loginResp // = 19

  ///发出撤消消息指令(管理员可以撤消所有人的消息，自己可以撤消自己的消息)
  case cancelMsgReq // = 21

  ///收到撤消消息指令
  case cancelMsgResp // = 22
  case UNRECOGNIZED(Int)

  init() {
    self = .unknow
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknow
    case 1: self = .handshakeReq
    case 2: self = .handshakeResp
    case 3: self = .authReq
    case 4: self = .authResp
    case 5: self = .joinGroupReq
    case 6: self = .joinGroupResp
    case 7: self = .joinGroupNotifyResp
    case 8: self = .chatReq
    case 9: self = .chatResp
    case 10: self = .startShowReq
    case 11: self = .startShowResp
    case 12: self = .endShowReq
    case 13: self = .endShowNotifyResp
    case 14: self = .heartbeatReq
    case 15: self = .closeReq
    case 16: self = .clientPageReq
    case 17: self = .clientPageResp
    case 18: self = .loginReq
    case 19: self = .loginResp
    case 20: self = .exitGroupNotifyResp
    case 21: self = .cancelMsgReq
    case 22: self = .cancelMsgResp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknow: return 0
    case .handshakeReq: return 1
    case .handshakeResp: return 2
    case .authReq: return 3
    case .authResp: return 4
    case .joinGroupReq: return 5
    case .joinGroupResp: return 6
    case .joinGroupNotifyResp: return 7
    case .chatReq: return 8
    case .chatResp: return 9
    case .startShowReq: return 10
    case .startShowResp: return 11
    case .endShowReq: return 12
    case .endShowNotifyResp: return 13
    case .heartbeatReq: return 14
    case .closeReq: return 15
    case .clientPageReq: return 16
    case .clientPageResp: return 17
    case .loginReq: return 18
    case .loginResp: return 19
    case .exitGroupNotifyResp: return 20
    case .cancelMsgReq: return 21
    case .cancelMsgResp: return 22
    case .UNRECOGNIZED(let i): return i
    }
  }

}

///*
///
/// 加入群组申请的结果
enum JoinGroupResult: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///不允许进入，原因为其它
  case unknow // = 0

  ///允许进入
  case ok // = 1

  ///组不存在
  case notExist // = 2

  ///组满
  case groupFull // = 3

  ///在黑名单中
  case inBacklist // = 4

  ///被踢
  case takeouted // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .unknow
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknow
    case 1: self = .ok
    case 2: self = .notExist
    case 3: self = .groupFull
    case 4: self = .inBacklist
    case 5: self = .takeouted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknow: return 0
    case .ok: return 1
    case .notExist: return 2
    case .groupFull: return 3
    case .inBacklist: return 4
    case .takeouted: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

///*
///
/// 聊天类型
enum ChatType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///未知
  case unknow // = 0

  ///公聊
  case `public` // = 1

  ///私聊
  case `private` // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknow
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknow
    case 1: self = .public
    case 2: self = .private
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknow: return 0
    case .public: return 1
    case .private: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

///*
///
/// 用户信息对象
struct User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///user id
  var id: String = String()

  ///user nick
  var nick: String = String()

  ///用户头像
  var avatar: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///
/// 群组信息
struct Group {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///group id
  var id: String = String()

  ///group nick
  var nick: String = String()

  ///group头像
  var avatar: String = String()

  ///群组总人数
  var total: Int32 = 0

  ///群组在线人数
  var online: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///
/// 客户端节点信息
struct Client {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///ChannelContext id
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  ///客户端ip
  var ip: String {
    get {return _storage._ip}
    set {_uniqueStorage()._ip = newValue}
  }

  ///客户端port
  var port: Int32 {
    get {return _storage._port}
    set {_uniqueStorage()._port = newValue}
  }

  ///如果没登录过，则为null
  var user: User {
    get {return _storage._user ?? User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_storage._user = nil}

  ///地区
  var region: String {
    get {return _storage._region}
    set {_uniqueStorage()._region = newValue}
  }

  ///浏览器信息
  var useragent: String {
    get {return _storage._useragent}
    set {_uniqueStorage()._useragent = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
///
/// 鉴权请求
struct AuthReqBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///鉴权token
  var token: String = String()

  /// device id(手机设备id)
  var deviceID: String = String()

  ///序列号
  var seq: Int64 = 0

  ///clienttype客户端类型1-pc 2-android 3-ios
  var deviceType: DeviceType = .unknow

  ///渠道号
  var cid: String = String()

  ///app版本号
  var appVersion: String = String()

  ///手机型号信息，譬如华为某型号
  var deviceInfo: String = String()

  ///签名
  var sign: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///
/// 鉴权响应，收到鉴权响应则表示鉴权通过，否则服务器端就直接断开连接了
struct AuthRespBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///
/// 登录请求
///
/// 要么用token登录，要么用用户名和密码登录
struct LoginReqBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var loginname: String = String()

  var password: String = String()

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///
/// 登录响应
struct LoginRespBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///用于免密码的token，登录成功才有
  var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  ///登录成功才有
  var user: User {
    get {return _storage._user ?? User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_storage._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
///
/// 加入群组请求
struct JoinGroupReqBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///
/// 加入群组响应
struct JoinGroupRespBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: JoinGroupResult = .unknow

  var group: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///进入群组通知消息体
struct JoinGroupNotifyRespBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var client: Client {
    get {return _storage._client ?? Client()}
    set {_uniqueStorage()._client = newValue}
  }
  /// Returns true if `client` has been explicitly set.
  var hasClient: Bool {return _storage._client != nil}
  /// Clears the value of `client`. Subsequent reads from it will return its default value.
  mutating func clearClient() {_storage._client = nil}

  var group: String {
    get {return _storage._group}
    set {_uniqueStorage()._group = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///退出群组通知消息体
struct ExitGroupNotifyRespBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var client: Client {
    get {return _storage._client ?? Client()}
    set {_uniqueStorage()._client = newValue}
  }
  /// Returns true if `client` has been explicitly set.
  var hasClient: Bool {return _storage._client != nil}
  /// Clears the value of `client`. Subsequent reads from it will return its default value.
  mutating func clearClient() {_storage._client = nil}

  var group: String {
    get {return _storage._group}
    set {_uniqueStorage()._group = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
///
/// 聊天请求
struct ChatReqBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///消息发送时间
  var time: Int64 = 0

  ///聊天类型
  var type: ChatType = .unknow

  ///聊天内容
  var text: String = String()

  ///消息发到哪个群组
  var group: String = String()

  ///目标channel id
  var toID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///
/// 聊天响应
struct ChatRespBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///消息发送时间
  var time: Int64 {
    get {return _storage._time}
    set {_uniqueStorage()._time = newValue}
  }

  ///聊天类型
  var type: ChatType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///聊天内容
  var text: String {
    get {return _storage._text}
    set {_uniqueStorage()._text = newValue}
  }

  var fromClient: Client {
    get {return _storage._fromClient ?? Client()}
    set {_uniqueStorage()._fromClient = newValue}
  }
  /// Returns true if `fromClient` has been explicitly set.
  var hasFromClient: Bool {return _storage._fromClient != nil}
  /// Clears the value of `fromClient`. Subsequent reads from it will return its default value.
  mutating func clearFromClient() {_storage._fromClient = nil}

  var toClient: Client {
    get {return _storage._toClient ?? Client()}
    set {_uniqueStorage()._toClient = newValue}
  }
  /// Returns true if `toClient` has been explicitly set.
  var hasToClient: Bool {return _storage._toClient != nil}
  /// Clears the value of `toClient`. Subsequent reads from it will return its default value.
  mutating func clearToClient() {_storage._toClient = nil}

  ///目标组id
  var group: String {
    get {return _storage._group}
    set {_uniqueStorage()._group = newValue}
  }

  ///消息id，全局唯一
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
///
/// 分页请求Client列表
struct ClientPageReqBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///第几页
  var pageIndex: Int32 = 0

  ///每页多少条
  var pageSize: Int32 = 0

  ///如果没有，则表示获取所有的
  var group: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///
/// Client分页列表
struct ClientPageRespBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///第几页
  var pageIndex: Int32 = 0

  ///每页多少条
  var pageSize: Int32 = 0

  ///总条数
  var recordCount: Int32 = 0

  var clients: [Client] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///
/// 开始直播请求
struct BeginToLiveReqBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///消息发送时间
  var time: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///
/// 开始直播响应
struct BeginToLiveRespBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///消息发送时间
  var time: Int64 = 0

  ///本次直播id
  var liveid: Int64 = 0

  ///rtmp推流地址
  var rtmppublishurl: String = String()

  ///rtmp播放地址
  var rtmpliveurl: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///
/// 结束直播请求
struct EndLiveReqBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///消息发送时间
  var time: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///
/// 结束直播响应
struct EndLiveRespBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///消息发送时间
  var time: Int64 = 0

  ///本次直播id
  var liveid: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension DeviceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_TYPE_UNKNOW"),
    1: .same(proto: "DEVICE_TYPE_PC"),
    2: .same(proto: "DEVICE_TYPE_ANDROID"),
    3: .same(proto: "DEVICE_TYPE_IOS"),
  ]
}

extension Command: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMAND_UNKNOW"),
    1: .same(proto: "COMMAND_HANDSHAKE_REQ"),
    2: .same(proto: "COMMAND_HANDSHAKE_RESP"),
    3: .same(proto: "COMMAND_AUTH_REQ"),
    4: .same(proto: "COMMAND_AUTH_RESP"),
    5: .same(proto: "COMMAND_JOIN_GROUP_REQ"),
    6: .same(proto: "COMMAND_JOIN_GROUP_RESP"),
    7: .same(proto: "COMMAND_JOIN_GROUP_NOTIFY_RESP"),
    8: .same(proto: "COMMAND_CHAT_REQ"),
    9: .same(proto: "COMMAND_CHAT_RESP"),
    10: .same(proto: "COMMAND_START_SHOW_REQ"),
    11: .same(proto: "COMMAND_START_SHOW_RESP"),
    12: .same(proto: "COMMAND_END_SHOW_REQ"),
    13: .same(proto: "COMMAND_END_SHOW_NOTIFY_RESP"),
    14: .same(proto: "COMMAND_HEARTBEAT_REQ"),
    15: .same(proto: "COMMAND_CLOSE_REQ"),
    16: .same(proto: "COMMAND_CLIENT_PAGE_REQ"),
    17: .same(proto: "COMMAND_CLIENT_PAGE_RESP"),
    18: .same(proto: "COMMAND_LOGIN_REQ"),
    19: .same(proto: "COMMAND_LOGIN_RESP"),
    20: .same(proto: "COMMAND_EXIT_GROUP_NOTIFY_RESP"),
    21: .same(proto: "COMMAND_CANCEL_MSG_REQ"),
    22: .same(proto: "COMMAND_CANCEL_MSG_RESP"),
  ]
}

extension JoinGroupResult: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "JOIN_GROUP_RESULT_UNKNOW"),
    1: .same(proto: "JOIN_GROUP_RESULT_OK"),
    2: .same(proto: "JOIN_GROUP_RESULT_NOT_EXIST"),
    3: .same(proto: "JOIN_GROUP_RESULT_GROUP_FULL"),
    4: .same(proto: "JOIN_GROUP_RESULT_IN_BACKLIST"),
    5: .same(proto: "JOIN_GROUP_RESULT_TAKEOUTED"),
  ]
}

extension ChatType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHAT_TYPE_UNKNOW"),
    1: .same(proto: "CHAT_TYPE_PUBLIC"),
    2: .same(proto: "CHAT_TYPE_PRIVATE"),
  ]
}

extension User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "nick"),
    3: .same(proto: "avatar"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.nick)
      case 3: try decoder.decodeSingularStringField(value: &self.avatar)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.nick.isEmpty {
      try visitor.visitSingularStringField(value: self.nick, fieldNumber: 2)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: User) -> Bool {
    if self.id != other.id {return false}
    if self.nick != other.nick {return false}
    if self.avatar != other.avatar {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "nick"),
    3: .same(proto: "avatar"),
    4: .same(proto: "total"),
    5: .same(proto: "online"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.nick)
      case 3: try decoder.decodeSingularStringField(value: &self.avatar)
      case 4: try decoder.decodeSingularInt32Field(value: &self.total)
      case 5: try decoder.decodeSingularInt32Field(value: &self.online)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.nick.isEmpty {
      try visitor.visitSingularStringField(value: self.nick, fieldNumber: 2)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 3)
    }
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 4)
    }
    if self.online != 0 {
      try visitor.visitSingularInt32Field(value: self.online, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Group) -> Bool {
    if self.id != other.id {return false}
    if self.nick != other.nick {return false}
    if self.avatar != other.avatar {return false}
    if self.total != other.total {return false}
    if self.online != other.online {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Client: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Client"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "ip"),
    3: .same(proto: "port"),
    4: .same(proto: "user"),
    5: .same(proto: "region"),
    6: .same(proto: "useragent"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _ip: String = String()
    var _port: Int32 = 0
    var _user: User? = nil
    var _region: String = String()
    var _useragent: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _ip = source._ip
      _port = source._port
      _user = source._user
      _region = source._region
      _useragent = source._useragent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._ip)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._port)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 5: try decoder.decodeSingularStringField(value: &_storage._region)
        case 6: try decoder.decodeSingularStringField(value: &_storage._useragent)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._ip.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ip, fieldNumber: 2)
      }
      if _storage._port != 0 {
        try visitor.visitSingularInt32Field(value: _storage._port, fieldNumber: 3)
      }
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._region.isEmpty {
        try visitor.visitSingularStringField(value: _storage._region, fieldNumber: 5)
      }
      if !_storage._useragent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._useragent, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Client) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._id != other_storage._id {return false}
        if _storage._ip != other_storage._ip {return false}
        if _storage._port != other_storage._port {return false}
        if _storage._user != other_storage._user {return false}
        if _storage._region != other_storage._region {return false}
        if _storage._useragent != other_storage._useragent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension AuthReqBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AuthReqBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "deviceId"),
    3: .same(proto: "seq"),
    4: .same(proto: "deviceType"),
    5: .same(proto: "cid"),
    6: .same(proto: "appVersion"),
    7: .same(proto: "deviceInfo"),
    8: .same(proto: "sign"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      case 2: try decoder.decodeSingularStringField(value: &self.deviceID)
      case 3: try decoder.decodeSingularInt64Field(value: &self.seq)
      case 4: try decoder.decodeSingularEnumField(value: &self.deviceType)
      case 5: try decoder.decodeSingularStringField(value: &self.cid)
      case 6: try decoder.decodeSingularStringField(value: &self.appVersion)
      case 7: try decoder.decodeSingularStringField(value: &self.deviceInfo)
      case 8: try decoder.decodeSingularStringField(value: &self.sign)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 2)
    }
    if self.seq != 0 {
      try visitor.visitSingularInt64Field(value: self.seq, fieldNumber: 3)
    }
    if self.deviceType != .unknow {
      try visitor.visitSingularEnumField(value: self.deviceType, fieldNumber: 4)
    }
    if !self.cid.isEmpty {
      try visitor.visitSingularStringField(value: self.cid, fieldNumber: 5)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 6)
    }
    if !self.deviceInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceInfo, fieldNumber: 7)
    }
    if !self.sign.isEmpty {
      try visitor.visitSingularStringField(value: self.sign, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: AuthReqBody) -> Bool {
    if self.token != other.token {return false}
    if self.deviceID != other.deviceID {return false}
    if self.seq != other.seq {return false}
    if self.deviceType != other.deviceType {return false}
    if self.cid != other.cid {return false}
    if self.appVersion != other.appVersion {return false}
    if self.deviceInfo != other.deviceInfo {return false}
    if self.sign != other.sign {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension AuthRespBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AuthRespBody"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: AuthRespBody) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension LoginReqBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginReqBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "loginname"),
    2: .same(proto: "password"),
    3: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.loginname)
      case 2: try decoder.decodeSingularStringField(value: &self.password)
      case 3: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.loginname.isEmpty {
      try visitor.visitSingularStringField(value: self.loginname, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: LoginReqBody) -> Bool {
    if self.loginname != other.loginname {return false}
    if self.password != other.password {return false}
    if self.token != other.token {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension LoginRespBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginRespBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "user"),
  ]

  fileprivate class _StorageClass {
    var _token: String = String()
    var _user: User? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _token = source._token
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._token)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._user)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 1)
      }
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: LoginRespBody) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._token != other_storage._token {return false}
        if _storage._user != other_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension JoinGroupReqBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "JoinGroupReqBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.group)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.group.isEmpty {
      try visitor.visitSingularStringField(value: self.group, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: JoinGroupReqBody) -> Bool {
    if self.group != other.group {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension JoinGroupRespBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "JoinGroupRespBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.result)
      case 2: try decoder.decodeSingularStringField(value: &self.group)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknow {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.group.isEmpty {
      try visitor.visitSingularStringField(value: self.group, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: JoinGroupRespBody) -> Bool {
    if self.result != other.result {return false}
    if self.group != other.group {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension JoinGroupNotifyRespBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "JoinGroupNotifyRespBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "client"),
    2: .same(proto: "group"),
  ]

  fileprivate class _StorageClass {
    var _client: Client? = nil
    var _group: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _client = source._client
      _group = source._group
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._client)
        case 2: try decoder.decodeSingularStringField(value: &_storage._group)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._client {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._group.isEmpty {
        try visitor.visitSingularStringField(value: _storage._group, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: JoinGroupNotifyRespBody) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._client != other_storage._client {return false}
        if _storage._group != other_storage._group {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ExitGroupNotifyRespBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ExitGroupNotifyRespBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "client"),
    2: .same(proto: "group"),
  ]

  fileprivate class _StorageClass {
    var _client: Client? = nil
    var _group: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _client = source._client
      _group = source._group
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._client)
        case 2: try decoder.decodeSingularStringField(value: &_storage._group)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._client {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._group.isEmpty {
        try visitor.visitSingularStringField(value: _storage._group, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: ExitGroupNotifyRespBody) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._client != other_storage._client {return false}
        if _storage._group != other_storage._group {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ChatReqBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChatReqBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "type"),
    3: .same(proto: "text"),
    4: .same(proto: "group"),
    5: .same(proto: "toId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.time)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      case 3: try decoder.decodeSingularStringField(value: &self.text)
      case 4: try decoder.decodeSingularStringField(value: &self.group)
      case 5: try decoder.decodeSingularStringField(value: &self.toID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 1)
    }
    if self.type != .unknow {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 3)
    }
    if !self.group.isEmpty {
      try visitor.visitSingularStringField(value: self.group, fieldNumber: 4)
    }
    if !self.toID.isEmpty {
      try visitor.visitSingularStringField(value: self.toID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: ChatReqBody) -> Bool {
    if self.time != other.time {return false}
    if self.type != other.type {return false}
    if self.text != other.text {return false}
    if self.group != other.group {return false}
    if self.toID != other.toID {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ChatRespBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChatRespBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "type"),
    3: .same(proto: "text"),
    4: .same(proto: "fromClient"),
    5: .same(proto: "toClient"),
    6: .same(proto: "group"),
    7: .same(proto: "id"),
  ]

  fileprivate class _StorageClass {
    var _time: Int64 = 0
    var _type: ChatType = .unknow
    var _text: String = String()
    var _fromClient: Client? = nil
    var _toClient: Client? = nil
    var _group: String = String()
    var _id: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _time = source._time
      _type = source._type
      _text = source._text
      _fromClient = source._fromClient
      _toClient = source._toClient
      _group = source._group
      _id = source._id
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._time)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 3: try decoder.decodeSingularStringField(value: &_storage._text)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._fromClient)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._toClient)
        case 6: try decoder.decodeSingularStringField(value: &_storage._group)
        case 7: try decoder.decodeSingularStringField(value: &_storage._id)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._time != 0 {
        try visitor.visitSingularInt64Field(value: _storage._time, fieldNumber: 1)
      }
      if _storage._type != .unknow {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if !_storage._text.isEmpty {
        try visitor.visitSingularStringField(value: _storage._text, fieldNumber: 3)
      }
      if let v = _storage._fromClient {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._toClient {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._group.isEmpty {
        try visitor.visitSingularStringField(value: _storage._group, fieldNumber: 6)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: ChatRespBody) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._time != other_storage._time {return false}
        if _storage._type != other_storage._type {return false}
        if _storage._text != other_storage._text {return false}
        if _storage._fromClient != other_storage._fromClient {return false}
        if _storage._toClient != other_storage._toClient {return false}
        if _storage._group != other_storage._group {return false}
        if _storage._id != other_storage._id {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ClientPageReqBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientPageReqBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pageIndex"),
    2: .same(proto: "pageSize"),
    3: .same(proto: "group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.pageIndex)
      case 2: try decoder.decodeSingularInt32Field(value: &self.pageSize)
      case 3: try decoder.decodeSingularStringField(value: &self.group)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.pageIndex, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.group.isEmpty {
      try visitor.visitSingularStringField(value: self.group, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: ClientPageReqBody) -> Bool {
    if self.pageIndex != other.pageIndex {return false}
    if self.pageSize != other.pageSize {return false}
    if self.group != other.group {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ClientPageRespBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientPageRespBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pageIndex"),
    2: .same(proto: "pageSize"),
    3: .same(proto: "recordCount"),
    4: .same(proto: "clients"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.pageIndex)
      case 2: try decoder.decodeSingularInt32Field(value: &self.pageSize)
      case 3: try decoder.decodeSingularInt32Field(value: &self.recordCount)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.clients)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.pageIndex, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if self.recordCount != 0 {
      try visitor.visitSingularInt32Field(value: self.recordCount, fieldNumber: 3)
    }
    if !self.clients.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clients, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: ClientPageRespBody) -> Bool {
    if self.pageIndex != other.pageIndex {return false}
    if self.pageSize != other.pageSize {return false}
    if self.recordCount != other.recordCount {return false}
    if self.clients != other.clients {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension BeginToLiveReqBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BeginToLiveReqBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.time)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: BeginToLiveReqBody) -> Bool {
    if self.time != other.time {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension BeginToLiveRespBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BeginToLiveRespBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "liveid"),
    3: .same(proto: "rtmppublishurl"),
    4: .same(proto: "rtmpliveurl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.time)
      case 2: try decoder.decodeSingularInt64Field(value: &self.liveid)
      case 3: try decoder.decodeSingularStringField(value: &self.rtmppublishurl)
      case 4: try decoder.decodeSingularStringField(value: &self.rtmpliveurl)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 1)
    }
    if self.liveid != 0 {
      try visitor.visitSingularInt64Field(value: self.liveid, fieldNumber: 2)
    }
    if !self.rtmppublishurl.isEmpty {
      try visitor.visitSingularStringField(value: self.rtmppublishurl, fieldNumber: 3)
    }
    if !self.rtmpliveurl.isEmpty {
      try visitor.visitSingularStringField(value: self.rtmpliveurl, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: BeginToLiveRespBody) -> Bool {
    if self.time != other.time {return false}
    if self.liveid != other.liveid {return false}
    if self.rtmppublishurl != other.rtmppublishurl {return false}
    if self.rtmpliveurl != other.rtmpliveurl {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension EndLiveReqBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EndLiveReqBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.time)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: EndLiveReqBody) -> Bool {
    if self.time != other.time {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension EndLiveRespBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EndLiveRespBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "liveid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.time)
      case 2: try decoder.decodeSingularInt64Field(value: &self.liveid)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 1)
    }
    if self.liveid != 0 {
      try visitor.visitSingularInt64Field(value: self.liveid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: EndLiveRespBody) -> Bool {
    if self.time != other.time {return false}
    if self.liveid != other.liveid {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
